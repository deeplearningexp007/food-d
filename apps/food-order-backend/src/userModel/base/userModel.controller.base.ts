/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import * as common from "@nestjs/common";
import * as swagger from "@nestjs/swagger";
import { isRecordNotFoundError } from "../../prisma.util";
import * as errors from "../../errors";
import { Request } from "express";
import { plainToClass } from "class-transformer";
import { ApiNestedQuery } from "../../decorators/api-nested-query.decorator";
import * as nestAccessControl from "nest-access-control";
import * as defaultAuthGuard from "../../auth/defaultAuth.guard";
import { UserModelService } from "../userModel.service";
import { AclValidateRequestInterceptor } from "../../interceptors/aclValidateRequest.interceptor";
import { AclFilterResponseInterceptor } from "../../interceptors/aclFilterResponse.interceptor";
import { UserModelCreateInput } from "./UserModelCreateInput";
import { UserModel } from "./UserModel";
import { UserModelFindManyArgs } from "./UserModelFindManyArgs";
import { UserModelWhereUniqueInput } from "./UserModelWhereUniqueInput";
import { UserModelUpdateInput } from "./UserModelUpdateInput";
import { AccessLogFindManyArgs } from "../../accessLog/base/AccessLogFindManyArgs";
import { AccessLog } from "../../accessLog/base/AccessLog";
import { AccessLogWhereUniqueInput } from "../../accessLog/base/AccessLogWhereUniqueInput";
import { CouponRedemptionFindManyArgs } from "../../couponRedemption/base/CouponRedemptionFindManyArgs";
import { CouponRedemption } from "../../couponRedemption/base/CouponRedemption";
import { CouponRedemptionWhereUniqueInput } from "../../couponRedemption/base/CouponRedemptionWhereUniqueInput";
import { CustomerPreferenceFindManyArgs } from "../../customerPreference/base/CustomerPreferenceFindManyArgs";
import { CustomerPreference } from "../../customerPreference/base/CustomerPreference";
import { CustomerPreferenceWhereUniqueInput } from "../../customerPreference/base/CustomerPreferenceWhereUniqueInput";
import { CustomerSubscriptionFindManyArgs } from "../../customerSubscription/base/CustomerSubscriptionFindManyArgs";
import { CustomerSubscription } from "../../customerSubscription/base/CustomerSubscription";
import { CustomerSubscriptionWhereUniqueInput } from "../../customerSubscription/base/CustomerSubscriptionWhereUniqueInput";
import { ErrorLogFindManyArgs } from "../../errorLog/base/ErrorLogFindManyArgs";
import { ErrorLog } from "../../errorLog/base/ErrorLog";
import { ErrorLogWhereUniqueInput } from "../../errorLog/base/ErrorLogWhereUniqueInput";
import { FavoriteFindManyArgs } from "../../favorite/base/FavoriteFindManyArgs";
import { Favorite } from "../../favorite/base/Favorite";
import { FavoriteWhereUniqueInput } from "../../favorite/base/FavoriteWhereUniqueInput";
import { NotificationFindManyArgs } from "../../notification/base/NotificationFindManyArgs";
import { Notification } from "../../notification/base/Notification";
import { NotificationWhereUniqueInput } from "../../notification/base/NotificationWhereUniqueInput";
import { NotificationSettingFindManyArgs } from "../../notificationSetting/base/NotificationSettingFindManyArgs";
import { NotificationSetting } from "../../notificationSetting/base/NotificationSetting";
import { NotificationSettingWhereUniqueInput } from "../../notificationSetting/base/NotificationSettingWhereUniqueInput";
import { OrderFindManyArgs } from "../../order/base/OrderFindManyArgs";
import { Order } from "../../order/base/Order";
import { OrderWhereUniqueInput } from "../../order/base/OrderWhereUniqueInput";
import { ReportFindManyArgs } from "../../report/base/ReportFindManyArgs";
import { Report } from "../../report/base/Report";
import { ReportWhereUniqueInput } from "../../report/base/ReportWhereUniqueInput";
import { ReservationFindManyArgs } from "../../reservation/base/ReservationFindManyArgs";
import { Reservation } from "../../reservation/base/Reservation";
import { ReservationWhereUniqueInput } from "../../reservation/base/ReservationWhereUniqueInput";
import { ReviewFindManyArgs } from "../../review/base/ReviewFindManyArgs";
import { Review } from "../../review/base/Review";
import { ReviewWhereUniqueInput } from "../../review/base/ReviewWhereUniqueInput";
import { RewardFindManyArgs } from "../../reward/base/RewardFindManyArgs";
import { Reward } from "../../reward/base/Reward";
import { RewardWhereUniqueInput } from "../../reward/base/RewardWhereUniqueInput";
import { SubscriptionFindManyArgs } from "../../subscription/base/SubscriptionFindManyArgs";
import { Subscription } from "../../subscription/base/Subscription";
import { SubscriptionWhereUniqueInput } from "../../subscription/base/SubscriptionWhereUniqueInput";
import { TransactionFindManyArgs } from "../../transaction/base/TransactionFindManyArgs";
import { Transaction } from "../../transaction/base/Transaction";
import { TransactionWhereUniqueInput } from "../../transaction/base/TransactionWhereUniqueInput";
import { UserAddressFindManyArgs } from "../../userAddress/base/UserAddressFindManyArgs";
import { UserAddress } from "../../userAddress/base/UserAddress";
import { UserAddressWhereUniqueInput } from "../../userAddress/base/UserAddressWhereUniqueInput";
import { WishlistFindManyArgs } from "../../wishlist/base/WishlistFindManyArgs";
import { Wishlist } from "../../wishlist/base/Wishlist";
import { WishlistWhereUniqueInput } from "../../wishlist/base/WishlistWhereUniqueInput";

@swagger.ApiBearerAuth()
@common.UseGuards(defaultAuthGuard.DefaultAuthGuard, nestAccessControl.ACGuard)
export class UserModelControllerBase {
  constructor(
    protected readonly service: UserModelService,
    protected readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {}
  @common.UseInterceptors(AclValidateRequestInterceptor)
  @common.Post()
  @swagger.ApiCreatedResponse({ type: UserModel })
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "create",
    possession: "any",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  async createUserModel(
    @common.Body() data: UserModelCreateInput
  ): Promise<UserModel> {
    return await this.service.createUserModel({
      data: data,
      select: {
        appleSsoToken: true,
        createdAt: true,
        email: true,
        emailPassword: true,
        facebookSsoToken: true,
        googleSsoToken: true,
        id: true,
        name: true,
        phoneNumber: true,
        twitterSsoToken: true,
        updatedAt: true,
      },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get()
  @swagger.ApiOkResponse({ type: [UserModel] })
  @ApiNestedQuery(UserModelFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "read",
    possession: "any",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  async userModels(@common.Req() request: Request): Promise<UserModel[]> {
    const args = plainToClass(UserModelFindManyArgs, request.query);
    return this.service.userModels({
      ...args,
      select: {
        appleSsoToken: true,
        createdAt: true,
        email: true,
        emailPassword: true,
        facebookSsoToken: true,
        googleSsoToken: true,
        id: true,
        name: true,
        phoneNumber: true,
        twitterSsoToken: true,
        updatedAt: true,
      },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id")
  @swagger.ApiOkResponse({ type: UserModel })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "read",
    possession: "own",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  async userModel(
    @common.Param() params: UserModelWhereUniqueInput
  ): Promise<UserModel | null> {
    const result = await this.service.userModel({
      where: params,
      select: {
        appleSsoToken: true,
        createdAt: true,
        email: true,
        emailPassword: true,
        facebookSsoToken: true,
        googleSsoToken: true,
        id: true,
        name: true,
        phoneNumber: true,
        twitterSsoToken: true,
        updatedAt: true,
      },
    });
    if (result === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return result;
  }

  @common.UseInterceptors(AclValidateRequestInterceptor)
  @common.Patch("/:id")
  @swagger.ApiOkResponse({ type: UserModel })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  async updateUserModel(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() data: UserModelUpdateInput
  ): Promise<UserModel | null> {
    try {
      return await this.service.updateUserModel({
        where: params,
        data: data,
        select: {
          appleSsoToken: true,
          createdAt: true,
          email: true,
          emailPassword: true,
          facebookSsoToken: true,
          googleSsoToken: true,
          id: true,
          name: true,
          phoneNumber: true,
          twitterSsoToken: true,
          updatedAt: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          `No resource was found for ${JSON.stringify(params)}`
        );
      }
      throw error;
    }
  }

  @common.Delete("/:id")
  @swagger.ApiOkResponse({ type: UserModel })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "delete",
    possession: "any",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  async deleteUserModel(
    @common.Param() params: UserModelWhereUniqueInput
  ): Promise<UserModel | null> {
    try {
      return await this.service.deleteUserModel({
        where: params,
        select: {
          appleSsoToken: true,
          createdAt: true,
          email: true,
          emailPassword: true,
          facebookSsoToken: true,
          googleSsoToken: true,
          id: true,
          name: true,
          phoneNumber: true,
          twitterSsoToken: true,
          updatedAt: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          `No resource was found for ${JSON.stringify(params)}`
        );
      }
      throw error;
    }
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/accessLogs")
  @ApiNestedQuery(AccessLogFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "AccessLog",
    action: "read",
    possession: "any",
  })
  async findAccessLogs(
    @common.Req() request: Request,
    @common.Param() params: UserModelWhereUniqueInput
  ): Promise<AccessLog[]> {
    const query = plainToClass(AccessLogFindManyArgs, request.query);
    const results = await this.service.findAccessLogs(params.id, {
      ...query,
      select: {
        action: true,
        deviceInfo: true,
        errorMessage: true,
        id: true,
        ipAddress: true,
        responseStatus: true,
        timestamp: true,

        userModels: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/accessLogs")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async connectAccessLogs(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: AccessLogWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      accessLogs: {
        connect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/accessLogs")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async updateAccessLogs(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: AccessLogWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      accessLogs: {
        set: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/accessLogs")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async disconnectAccessLogs(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: AccessLogWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      accessLogs: {
        disconnect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/couponRedemptions")
  @ApiNestedQuery(CouponRedemptionFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "CouponRedemption",
    action: "read",
    possession: "any",
  })
  async findCouponRedemptions(
    @common.Req() request: Request,
    @common.Param() params: UserModelWhereUniqueInput
  ): Promise<CouponRedemption[]> {
    const query = plainToClass(CouponRedemptionFindManyArgs, request.query);
    const results = await this.service.findCouponRedemptions(params.id, {
      ...query,
      select: {
        coupons: {
          select: {
            id: true,
          },
        },

        id: true,
        isRedeemed: true,
        redemptionDate: true,

        userModels: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/couponRedemptions")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async connectCouponRedemptions(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: CouponRedemptionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      couponRedemptions: {
        connect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/couponRedemptions")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async updateCouponRedemptions(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: CouponRedemptionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      couponRedemptions: {
        set: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/couponRedemptions")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async disconnectCouponRedemptions(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: CouponRedemptionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      couponRedemptions: {
        disconnect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/customerPreferences")
  @ApiNestedQuery(CustomerPreferenceFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "CustomerPreference",
    action: "read",
    possession: "any",
  })
  async findCustomerPreferences(
    @common.Req() request: Request,
    @common.Param() params: UserModelWhereUniqueInput
  ): Promise<CustomerPreference[]> {
    const query = plainToClass(CustomerPreferenceFindManyArgs, request.query);
    const results = await this.service.findCustomerPreferences(params.id, {
      ...query,
      select: {
        createdAt: true,
        id: true,
        preferenceType: true,
        preferenceValue: true,
        updatedAt: true,

        userModels: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/customerPreferences")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async connectCustomerPreferences(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: CustomerPreferenceWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      customerPreferences: {
        connect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/customerPreferences")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async updateCustomerPreferences(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: CustomerPreferenceWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      customerPreferences: {
        set: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/customerPreferences")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async disconnectCustomerPreferences(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: CustomerPreferenceWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      customerPreferences: {
        disconnect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/customerSubscriptions")
  @ApiNestedQuery(CustomerSubscriptionFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "CustomerSubscription",
    action: "read",
    possession: "any",
  })
  async findCustomerSubscriptions(
    @common.Req() request: Request,
    @common.Param() params: UserModelWhereUniqueInput
  ): Promise<CustomerSubscription[]> {
    const query = plainToClass(CustomerSubscriptionFindManyArgs, request.query);
    const results = await this.service.findCustomerSubscriptions(params.id, {
      ...query,
      select: {
        activationDate: true,
        createdAt: true,
        expirationDate: true,
        id: true,
        renewalCount: true,

        subscriptionPlans: {
          select: {
            id: true,
          },
        },

        subscriptions: {
          select: {
            id: true,
          },
        },

        updatedAt: true,

        userModels: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/customerSubscriptions")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async connectCustomerSubscriptions(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: CustomerSubscriptionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      customerSubscriptions: {
        connect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/customerSubscriptions")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async updateCustomerSubscriptions(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: CustomerSubscriptionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      customerSubscriptions: {
        set: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/customerSubscriptions")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async disconnectCustomerSubscriptions(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: CustomerSubscriptionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      customerSubscriptions: {
        disconnect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/errorLogs")
  @ApiNestedQuery(ErrorLogFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "ErrorLog",
    action: "read",
    possession: "any",
  })
  async findErrorLogs(
    @common.Req() request: Request,
    @common.Param() params: UserModelWhereUniqueInput
  ): Promise<ErrorLog[]> {
    const query = plainToClass(ErrorLogFindManyArgs, request.query);
    const results = await this.service.findErrorLogs(params.id, {
      ...query,
      select: {
        errorCode: true,
        errorMessage: true,
        id: true,
        requestInfo: true,
        stackTrace: true,
        timestamp: true,

        userModels: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/errorLogs")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async connectErrorLogs(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: ErrorLogWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      errorLogs: {
        connect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/errorLogs")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async updateErrorLogs(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: ErrorLogWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      errorLogs: {
        set: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/errorLogs")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async disconnectErrorLogs(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: ErrorLogWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      errorLogs: {
        disconnect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/favorites")
  @ApiNestedQuery(FavoriteFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "Favorite",
    action: "read",
    possession: "any",
  })
  async findFavorites(
    @common.Req() request: Request,
    @common.Param() params: UserModelWhereUniqueInput
  ): Promise<Favorite[]> {
    const query = plainToClass(FavoriteFindManyArgs, request.query);
    const results = await this.service.findFavorites(params.id, {
      ...query,
      select: {
        createdAt: true,
        id: true,
        updatedAt: true,

        userModels: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/favorites")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async connectFavorites(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: FavoriteWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      favorites: {
        connect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/favorites")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async updateFavorites(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: FavoriteWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      favorites: {
        set: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/favorites")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async disconnectFavorites(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: FavoriteWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      favorites: {
        disconnect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/notifications")
  @ApiNestedQuery(NotificationFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "Notification",
    action: "read",
    possession: "any",
  })
  async findNotifications(
    @common.Req() request: Request,
    @common.Param() params: UserModelWhereUniqueInput
  ): Promise<Notification[]> {
    const query = plainToClass(NotificationFindManyArgs, request.query);
    const results = await this.service.findNotifications(params.id, {
      ...query,
      select: {
        createdAt: true,
        id: true,
        isRead: true,
        message: true,

        userModels: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/notifications")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async connectNotifications(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: NotificationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      notifications: {
        connect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/notifications")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async updateNotifications(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: NotificationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      notifications: {
        set: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/notifications")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async disconnectNotifications(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: NotificationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      notifications: {
        disconnect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/notificationSettings")
  @ApiNestedQuery(NotificationSettingFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "NotificationSetting",
    action: "read",
    possession: "any",
  })
  async findNotificationSettings(
    @common.Req() request: Request,
    @common.Param() params: UserModelWhereUniqueInput
  ): Promise<NotificationSetting[]> {
    const query = plainToClass(NotificationSettingFindManyArgs, request.query);
    const results = await this.service.findNotificationSettings(params.id, {
      ...query,
      select: {
        createdAt: true,
        id: true,
        settingName: true,
        settingValue: true,
        updatedAt: true,

        userModels: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/notificationSettings")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async connectNotificationSettings(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: NotificationSettingWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      notificationSettings: {
        connect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/notificationSettings")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async updateNotificationSettings(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: NotificationSettingWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      notificationSettings: {
        set: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/notificationSettings")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async disconnectNotificationSettings(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: NotificationSettingWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      notificationSettings: {
        disconnect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/orders")
  @ApiNestedQuery(OrderFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "Order",
    action: "read",
    possession: "any",
  })
  async findOrders(
    @common.Req() request: Request,
    @common.Param() params: UserModelWhereUniqueInput
  ): Promise<Order[]> {
    const query = plainToClass(OrderFindManyArgs, request.query);
    const results = await this.service.findOrders(params.id, {
      ...query,
      select: {
        coupons: {
          select: {
            id: true,
          },
        },

        deliveryTime: true,
        discountAmount: true,
        finalAmount: true,
        id: true,
        isDelivered: true,
        isPaid: true,
        orderDate: true,
        orderType: true,

        paymentMethods: {
          select: {
            id: true,
          },
        },

        restaurants: {
          select: {
            id: true,
          },
        },

        scheduledDeliveryTime: true,
        specialInstructions: true,
        status: true,
        totalAmount: true,

        userAddresses: {
          select: {
            id: true,
          },
        },

        userModels: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/orders")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async connectOrders(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: OrderWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      orders: {
        connect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/orders")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async updateOrders(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: OrderWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      orders: {
        set: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/orders")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async disconnectOrders(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: OrderWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      orders: {
        disconnect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/reports")
  @ApiNestedQuery(ReportFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "Report",
    action: "read",
    possession: "any",
  })
  async findReports(
    @common.Req() request: Request,
    @common.Param() params: UserModelWhereUniqueInput
  ): Promise<Report[]> {
    const query = plainToClass(ReportFindManyArgs, request.query);
    const results = await this.service.findReports(params.id, {
      ...query,
      select: {
        createdAt: true,
        id: true,
        reportData: true,
        reportType: true,
        updatedAt: true,

        userModels: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/reports")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async connectReports(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: ReportWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      reports: {
        connect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/reports")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async updateReports(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: ReportWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      reports: {
        set: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/reports")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async disconnectReports(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: ReportWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      reports: {
        disconnect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/reservations")
  @ApiNestedQuery(ReservationFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "Reservation",
    action: "read",
    possession: "any",
  })
  async findReservations(
    @common.Req() request: Request,
    @common.Param() params: UserModelWhereUniqueInput
  ): Promise<Reservation[]> {
    const query = plainToClass(ReservationFindManyArgs, request.query);
    const results = await this.service.findReservations(params.id, {
      ...query,
      select: {
        createdAt: true,
        id: true,
        partySize: true,
        reservationDate: true,
        reservationTime: true,

        restaurants: {
          select: {
            id: true,
          },
        },

        status: true,
        updatedAt: true,

        userModels: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/reservations")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async connectReservations(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: ReservationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      reservations: {
        connect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/reservations")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async updateReservations(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: ReservationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      reservations: {
        set: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/reservations")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async disconnectReservations(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: ReservationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      reservations: {
        disconnect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/reviews")
  @ApiNestedQuery(ReviewFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "Review",
    action: "read",
    possession: "any",
  })
  async findReviews(
    @common.Req() request: Request,
    @common.Param() params: UserModelWhereUniqueInput
  ): Promise<Review[]> {
    const query = plainToClass(ReviewFindManyArgs, request.query);
    const results = await this.service.findReviews(params.id, {
      ...query,
      select: {
        body: true,
        createdAt: true,
        id: true,
        rating: true,

        restaurants: {
          select: {
            id: true,
          },
        },

        title: true,
        updatedAt: true,

        userModels: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/reviews")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async connectReviews(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: ReviewWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      reviews: {
        connect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/reviews")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async updateReviews(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: ReviewWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      reviews: {
        set: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/reviews")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async disconnectReviews(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: ReviewWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      reviews: {
        disconnect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/rewards")
  @ApiNestedQuery(RewardFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "Reward",
    action: "read",
    possession: "any",
  })
  async findRewards(
    @common.Req() request: Request,
    @common.Param() params: UserModelWhereUniqueInput
  ): Promise<Reward[]> {
    const query = plainToClass(RewardFindManyArgs, request.query);
    const results = await this.service.findRewards(params.id, {
      ...query,
      select: {
        createdAt: true,
        expirationDate: true,
        id: true,
        points: true,
        updatedAt: true,

        userModels: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/rewards")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async connectRewards(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: RewardWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      rewards: {
        connect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/rewards")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async updateRewards(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: RewardWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      rewards: {
        set: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/rewards")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async disconnectRewards(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: RewardWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      rewards: {
        disconnect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/subscriptions")
  @ApiNestedQuery(SubscriptionFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "Subscription",
    action: "read",
    possession: "any",
  })
  async findSubscriptions(
    @common.Req() request: Request,
    @common.Param() params: UserModelWhereUniqueInput
  ): Promise<Subscription[]> {
    const query = plainToClass(SubscriptionFindManyArgs, request.query);
    const results = await this.service.findSubscriptions(params.id, {
      ...query,
      select: {
        autoRenew: true,
        createdAt: true,
        endDate: true,
        id: true,
        paymentStatus: true,
        startDate: true,
        status: true,

        subscriptionPlans: {
          select: {
            id: true,
          },
        },

        updatedAt: true,

        userModels: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/subscriptions")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async connectSubscriptions(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: SubscriptionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      subscriptions: {
        connect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/subscriptions")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async updateSubscriptions(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: SubscriptionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      subscriptions: {
        set: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/subscriptions")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async disconnectSubscriptions(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: SubscriptionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      subscriptions: {
        disconnect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/transactions")
  @ApiNestedQuery(TransactionFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "Transaction",
    action: "read",
    possession: "any",
  })
  async findTransactions(
    @common.Req() request: Request,
    @common.Param() params: UserModelWhereUniqueInput
  ): Promise<Transaction[]> {
    const query = plainToClass(TransactionFindManyArgs, request.query);
    const results = await this.service.findTransactions(params.id, {
      ...query,
      select: {
        amount: true,
        createdAt: true,
        id: true,

        orders: {
          select: {
            id: true,
          },
        },

        status: true,
        transactionType: true,
        updatedAt: true,

        userModels: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/transactions")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async connectTransactions(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: TransactionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      transactions: {
        connect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/transactions")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async updateTransactions(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: TransactionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      transactions: {
        set: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/transactions")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async disconnectTransactions(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: TransactionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      transactions: {
        disconnect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/userAddresses")
  @ApiNestedQuery(UserAddressFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "UserAddress",
    action: "read",
    possession: "any",
  })
  async findUserAddresses(
    @common.Req() request: Request,
    @common.Param() params: UserModelWhereUniqueInput
  ): Promise<UserAddress[]> {
    const query = plainToClass(UserAddressFindManyArgs, request.query);
    const results = await this.service.findUserAddresses(params.id, {
      ...query,
      select: {
        addressLine1: true,
        addressLine2: true,
        city: true,
        country: true,
        createdAt: true,
        id: true,
        isPrimary: true,
        pincode: true,
        state: true,
        updatedAt: true,

        userModels: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/userAddresses")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async connectUserAddresses(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: UserAddressWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      userAddresses: {
        connect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/userAddresses")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async updateUserAddresses(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: UserAddressWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      userAddresses: {
        set: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/userAddresses")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async disconnectUserAddresses(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: UserAddressWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      userAddresses: {
        disconnect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/wishlist")
  @ApiNestedQuery(WishlistFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "Wishlist",
    action: "read",
    possession: "any",
  })
  async findWishlist(
    @common.Req() request: Request,
    @common.Param() params: UserModelWhereUniqueInput
  ): Promise<Wishlist[]> {
    const query = plainToClass(WishlistFindManyArgs, request.query);
    const results = await this.service.findWishlist(params.id, {
      ...query,
      select: {
        createdAt: true,
        id: true,
        itemId: true,
        itemType: true,
        updatedAt: true,

        userModels: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/wishlist")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async connectWishlist(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: WishlistWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      wishlist: {
        connect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/wishlist")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async updateWishlist(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: WishlistWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      wishlist: {
        set: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/wishlist")
  @nestAccessControl.UseRoles({
    resource: "UserModel",
    action: "update",
    possession: "any",
  })
  async disconnectWishlist(
    @common.Param() params: UserModelWhereUniqueInput,
    @common.Body() body: WishlistWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      wishlist: {
        disconnect: body,
      },
    };
    await this.service.updateUserModel({
      where: params,
      data,
      select: { id: true },
    });
  }
}
